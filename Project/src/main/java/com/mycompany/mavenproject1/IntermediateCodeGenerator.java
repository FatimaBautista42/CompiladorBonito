package com.mycompany.mavenproject1;

public class IntermediateCodeGenerator extends javax.swing.JFrame 
{
    public static int VariableNumber = 1;
    public static int LabelNumber = 1;
    /**
     * Creates new form Intermediate
     * @param text
     */
    public IntermediateCodeGenerator(String text) {
        initComponents();
        String newCode = ConvertCode(text);
        newCode = performFormat(newCode);
        this.jTextArea1.setText(newCode);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setTitle("Intermediate Code Generator");

        jLabel1.setFont(new java.awt.Font("Arial", 1, 24)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("3 Address Code");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(184, 184, 184)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 251, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(190, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 404, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Utility Functions
    public static String ConvertCode(String text){
        VariableNumber = 1;
        LabelNumber = 1;
        String finalCode = "";
        String[] lines = text.split("\n");
        for (String line : lines){
            line = line.trim().replaceAll(";$", ""); // Remove trailing semicolon
            if (isIgnoredLine(line)) continue; // Ignorar líneas no soportadas
            if (isIfStatement(line)){
                String ifCode = processIfStatement(line);
                finalCode += ifCode + "\n";
            }
            else if (isWhileStatement(line)){
                String whileCode = processWhileStatement(line);
                finalCode += whileCode + "\n";
            }
            else if (isForStatement(line)){
                String forCode = processForStatement(line);
                finalCode += forCode + "\n";
            }
            else if (isFunctionDeclaration(line)){
                String funcCode = processFunctionDeclaration(line);
                finalCode += funcCode + "\n";
            }
            else if (isExpressionLine(line)){
                String UpdatedLine = ThreeAddressCode.GenerateCode(line);
                finalCode += UpdatedLine + "\n";
            }
            else {
                finalCode += line + "\n";
            }
        }
        return finalCode;
    }
    
    private static boolean isExpressionLine(String text){ 
        if(text.contains("while") || text.contains("for") || text.contains("do") || 
                text.contains("if") || text.contains("else") || text.contains("private") ||
                text.contains("public") || text.contains("protected") || text.contains("abstract") ||
                text.contains("class") || text.contains("break") || text.contains("continue") ||
                text.contains("try") || text.contains("catch") || text.contains("finally") || 
                text.contains("case") || text.contains("default") || text.contains("enum") || 
                text.contains("extends") || text.contains("implements") || text.contains("interface") ||
                text.contains("package") || text.contains("return") || text.contains("synchronized") || text.equals("throw")) 
        {
            return false;
        }
        else if (text.contains("=") && (text.contains("+") || text.contains("-") || text.contains("/") || text.contains("*") || text.contains("%"))){
            return true;
        }
        else {
            return false;
        }
    }
    
    private static boolean isIfStatement(String line) {
        return line.startsWith("if");
    }
    
    private static boolean isWhileStatement(String line) {
        return line.startsWith("while");
    }
    
    private static boolean isForStatement(String line) {
        return line.startsWith("for");
    }
    
    private static boolean isFunctionDeclaration(String line) {
        return (line.contains("int ") || line.contains("double ") || line.contains("String ") || 
                line.contains("boolean ") || line.contains("void ")) && 
               line.contains("(") && line.contains(")") && !line.contains("=");
    }
    
    private static String processIfStatement(String line) {
        // Extraer la condición del if
        int startParen = line.indexOf('(');
        int endParen = line.lastIndexOf(')');
        if (startParen == -1 || endParen == -1) return line;
        
        String condition = line.substring(startParen + 1, endParen).trim();
        String label = "L" + LabelNumber++;
        
        // Generar código de tres direcciones para el if
        String code = "// if " + condition + "\n";
        code += "if " + condition + " == false goto " + label + "\n";
        // Aquí iría el código del bloque if
        code += label + ":";
        
        return code;
    }
    
    private static String processWhileStatement(String line) {
        // Extraer la condición del while
        int startParen = line.indexOf('(');
        int endParen = line.lastIndexOf(')');
        if (startParen == -1 || endParen == -1) return line;
        
        String condition = line.substring(startParen + 1, endParen).trim();
        String startLabel = "L" + LabelNumber++;
        String endLabel = "L" + LabelNumber++;
        
        // Generar código de tres direcciones para el while
        String code = startLabel + ":\n";
        code += "// while " + condition + "\n";
        code += "if " + condition + " == false goto " + endLabel + "\n";
        // Aquí iría el código del bloque while
        code += "goto " + startLabel + "\n";
        code += endLabel + ":";
        
        return code;
    }
    
    private static String processForStatement(String line) {
        // Extraer las partes del for: inicialización, condición, incremento
        int startParen = line.indexOf('(');
        int endParen = line.lastIndexOf(')');
        if (startParen == -1 || endParen == -1) return line;
        
        String forContent = line.substring(startParen + 1, endParen);
        String[] parts = forContent.split(";");
        if (parts.length != 3) return line;
        
        String initialization = parts[0].trim();
        String condition = parts[1].trim();
        String increment = parts[2].trim();
        
        String startLabel = "L" + LabelNumber++;
        String endLabel = "L" + LabelNumber++;
        
        // Generar código de tres direcciones para el for
        String code = "// for (" + initialization + "; " + condition + "; " + increment + ")\n";
        code += initialization + "\n";
        code += startLabel + ":\n";
        code += "if " + condition + " == false goto " + endLabel + "\n";
        // Aquí iría el código del bloque for
        code += increment + "\n";
        code += "goto " + startLabel + "\n";
        code += endLabel + ":";
        
        return code;
    }
    
    private static String processFunctionDeclaration(String line) {
        // Extraer el nombre de la función
        int parenIndex = line.indexOf("(");
        String beforeParen = line.substring(0, parenIndex).trim();
        String[] tokens = beforeParen.split("\\s+");
        String functionName = tokens[tokens.length - 1];
        
        // Generar código de tres direcciones para la función
        String code = "// Function " + functionName + "\n";
        code += "function " + functionName + ":\n";
        // Aquí iría el código del cuerpo de la función
        code += "return";
        
        return code;
    }
    
    private static boolean isIgnoredLine(String line) {
        return line.contains("import") || line.contains("class") || line.contains("main") || 
               line.contains("Scanner") || line.contains("System.out");
    }
    public static String performFormat(String text){
        String lines[] = text.split("\n");
        String spaces = "";
        for(int i=0; i<lines.length; i++){
            lines[i] = lines[i].trim();
            if(lines[i].contains("{") && lines[i].contains("}")){
                lines[i] = spaces + lines[i];
            }
            else if(lines[i].contains("{")){
                lines[i] = spaces + lines[i];
                spaces += "    ";
            }
            else if(lines[i].contains("}")){
                if(spaces.length() > 5){
                    spaces = spaces.substring(0, spaces.length()-5);
                }
                else{
                    spaces = "";
                }
                lines[i] = spaces + lines[i];
            }
            else{
                lines[i] = spaces + lines[i];
            }
        }
        String newString = "";
        for(String s : lines){
            newString += s + " \n";
        }
        return newString;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}
